<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ILUMA.i</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <style>
        /* Estilos base */
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: black;
            color: white;
        }

        /* Animações */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Animações da moldura */
        @keyframes glow {
            0% { 
                filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8));
                opacity: 0.85;
            }
            50% { 
                filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.95));
                opacity: 1;
            }
            100% { 
                filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8));
                opacity: 0.85;
            }
        }
        
        @keyframes dotPulse {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(0.95); }
        }
        
        .circle-glow {
            animation: glow 4s ease-in-out infinite;
        }
        
        .circle-pulse {
            animation: dotPulse 4s ease-in-out infinite;
        }
        
        .circle-animated {
            transform-origin: center;
            transform-box: fill-box;
        }

        /* Classes Tailwind comuns */
        .fixed { position: fixed; }
        .absolute { position: absolute; }
        .relative { position: relative; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-center: center; }
        .text-white { color: white; }
        .text-center { text-align: center; }
        .p-4 { padding: 1rem; }
        .text-sm { font-size: 0.875rem; }
        .mt-2 { margin-top: 0.5rem; }
        .opacity-75 { opacity: 0.75; }
        .bg-black { background-color: black; }
        .overflow-hidden { overflow: hidden; }
        .w-auto { width: auto; }
        .h-auto { height: auto; }
        .object-cover { object-fit: cover; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .h-screen { height: 100vh; }
        .z-10 { z-index: 10; }
        .z-20 { z-index: 20; }
        .pointer-events-none { pointer-events: none; }
        .cursor-pointer { cursor: pointer; }
        .aspect-square { aspect-ratio: 1 / 1; }

        /* Estilos específicos */
        .color-ball {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin: 0 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-ball:hover {
            transform: scale(1.2);
        }

        .color-ball.selected {
            border: 2px solid white;
            transform: scale(1.2);
        }

        /* Gradientes e cores */
        .from-gray-900 { --tw-gradient-from: #111827; }
        .to-black { --tw-gradient-to: #000000; }
        .bg-gradient-to-b {
            background-image: linear-gradient(to bottom, var(--tw-gradient-from), var(--tw-gradient-to));
        }

        /* Transições e transformações */
        .transform { transform: translateX(-50%); }
        .transition-colors { transition-property: background-color, border-color, color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .hover\:bg-opacity-90:hover { --tw-bg-opacity: 0.9; }
        .hover\:text-gray-300:hover { --tw-text-opacity: 1; color: rgba(209, 213, 219, var(--tw-text-opacity)); }
        
        /* Botões */
        .rounded-full { border-radius: 9999px; }
        .bg-white { background-color: white; }
        .text-black { color: black; }
        
        /* Responsividade */
        @media (min-width: 640px) {
            .sm\:w-40\% { width: 40%; }
            .sm\:w-25\% { width: 25%; }
        }
        
        @media (min-width: 768px) {
            .md\:w-35\% { width: 35%; }
            .md\:w-20\% { width: 20%; }
            .md\:h-80vh { height: 80vh; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="module">
        // Configurações e dados
        const machines = [
            { id: 1, name: "ILUMAi Breeze", image: "public/IMG/ILUMAi/ILUMAi_BREEZE.png", baseModel: "ILUMAi" },
            { id: 2, name: "ILUMAi Prime Breeze", image: "public/IMG/ILUMAi-PRIME/ILUMAi-PRIME_BREEZE.png", baseModel: "ILUMAi-PRIME" },
            { id: 3, name: "ILUMAi One Breeze", image: "public/IMG/ILUMAi-ONE/ILUMAi-ONE_BREEZE.png", baseModel: "ILUMAi-ONE" },
        ];

        const colorConfig = [
            { color: "#3A3D4A", variant: "Midnight", label: "Midnight" },
            { color: "#95C4C7", variant: "Breeze", label: "Breeze" },
            { color: "#8F993D", variant: "Leaf", label: "Leaf" },
            { color: "#AA4C3A", variant: "Terracotta", label: "Terracotta" },
            { color: "#8690CA", variant: "Violet", label: "Violet", availableFor: ["ILUMAi", "ILUMAi-ONE"] },
        ];

        // Componente App principal
        const App = () => {
            const [showCamera, setShowCamera] = React.useState(false);

            return React.createElement(React.Fragment, null,
                React.createElement(CameraBackground),
                React.createElement(DotFrame),
                React.createElement(Carousel)
            );
        };

        // Componente DotFrame
        const DotFrame = () => {
            const [viewport, setViewport] = React.useState({
                width: typeof window !== 'undefined' ? window.innerWidth : 390,
                height: typeof window !== 'undefined' ? window.innerHeight : 844
            });

            React.useEffect(() => {
                const handleResize = () => {
                    setViewport({
                        width: window.innerWidth,
                        height: window.innerHeight
                    });
                };

                window.addEventListener('resize', handleResize);
                handleResize();

                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Configurações da moldura
            const circleRadius = 10;
            const spacing = 30;
            const borderOffset = 25;
            const innerOffset = borderOffset + 30;
            const cornerRadius = Math.min(viewport.width, viewport.height) / 2.2;

            // Calcular número de círculos para cada lado
            const straightHorizontalLength = Math.max(0, viewport.width - 2 * cornerRadius);
            const straightVerticalLength = Math.max(0, viewport.height - 2 * cornerRadius);
            const horizontalCircles = Math.max(0, Math.floor(straightHorizontalLength / spacing) + 1);
            const verticalCircles = Math.max(0, Math.floor(straightVerticalLength / spacing) + 1);

            // Função para calcular a distância entre dois pontos
            const distance = (x1, y1, x2, y2) => {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            };

            // Função para gerar pontos dos cantos arredondados
            const generateCornerPoints = (cornerX, cornerY, startAngle, endAngle, radius, isInner) => {
                const points = [];
                const offsetRadius = isInner ? innerOffset : borderOffset;
                const actualRadius = radius - offsetRadius;
                const angleRange = Math.abs(endAngle - startAngle);
                const arcLength = angleRange * actualRadius;
                const pointCount = Math.max(2, Math.floor(arcLength / spacing));

                for (let i = 0; i <= pointCount; i++) {
                    const angle = startAngle + (angleRange * i) / pointCount;
                    const x = cornerX + Math.cos(angle) * actualRadius;
                    const y = cornerY + Math.sin(angle) * actualRadius;

                    if (i === 0 || i === pointCount || distance(
                        points[points.length - 1]?.x || x,
                        points[points.length - 1]?.y || y,
                        x,
                        y
                    ) >= spacing * 0.9) {
                        points.push({ x, y });
                    }
                }

                return points;
            };

            // Função para gerar atrasos aleatórios para animações
            const getRandomDelay = () => {
                return Math.floor(Math.random() * 10) * 0.2;
            };

            return React.createElement('div', { className: 'fixed inset-0 pointer-events-none z-50' },
                React.createElement('svg', {
                    width: '100%',
                    height: '100%',
                    viewBox: `0 0 ${viewport.width} ${viewport.height}`,
                    preserveAspectRatio: 'xMidYMid meet',
                    className: 'w-full h-full'
                },
                    React.createElement('defs',
                        null,
                        React.createElement('filter',
                            { id: 'glow' },
                            React.createElement('feGaussianBlur', { stdDeviation: '2.5', result: 'coloredBlur' }),
                            React.createElement('feMerge',
                                null,
                                React.createElement('feMergeNode', { in: 'coloredBlur' }),
                                React.createElement('feMergeNode', { in: 'SourceGraphic' })
                            )
                        )
                    ),

                    // Círculos externos
                    // Superior
                    [...Array(horizontalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `top-outer-${i}`,
                            cx: cornerRadius + i * spacing,
                            cy: borderOffset,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto superior direito
                    generateCornerPoints(
                        viewport.width - cornerRadius,
                        cornerRadius,
                        -Math.PI/2,
                        0,
                        cornerRadius,
                        false
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `top-right-outer-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Direita
                    [...Array(verticalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `right-outer-${i}`,
                            cx: viewport.width - borderOffset,
                            cy: cornerRadius + i * spacing,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto inferior direito
                    generateCornerPoints(
                        viewport.width - cornerRadius,
                        viewport.height - cornerRadius,
                        0,
                        Math.PI/2,
                        cornerRadius,
                        false
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `bottom-right-outer-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Inferior
                    [...Array(horizontalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `bottom-outer-${i}`,
                            cx: viewport.width - cornerRadius - i * spacing,
                            cy: viewport.height - borderOffset,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto inferior esquerdo
                    generateCornerPoints(
                        cornerRadius,
                        viewport.height - cornerRadius,
                        Math.PI/2,
                        Math.PI,
                        cornerRadius,
                        false
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `bottom-left-outer-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Esquerda
                    [...Array(verticalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `left-outer-${i}`,
                            cx: borderOffset,
                            cy: viewport.height - cornerRadius - i * spacing,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto superior esquerdo
                    generateCornerPoints(
                        cornerRadius,
                        cornerRadius,
                        Math.PI,
                        Math.PI * 3/2,
                        cornerRadius,
                        false
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `top-left-outer-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-glow',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Círculos internos
                    // Superior
                    [...Array(horizontalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `top-inner-${i}`,
                            cx: cornerRadius + i * spacing,
                            cy: innerOffset,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto superior direito
                    generateCornerPoints(
                        viewport.width - cornerRadius,
                        cornerRadius,
                        -Math.PI/2,
                        0,
                        cornerRadius,
                        true
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `top-right-inner-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Direita
                    [...Array(verticalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `right-inner-${i}`,
                            cx: viewport.width - innerOffset,
                            cy: cornerRadius + i * spacing,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto inferior direito
                    generateCornerPoints(
                        viewport.width - cornerRadius,
                        viewport.height - cornerRadius,
                        0,
                        Math.PI/2,
                        cornerRadius,
                        true
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `bottom-right-inner-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Inferior
                    [...Array(horizontalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `bottom-inner-${i}`,
                            cx: viewport.width - cornerRadius - i * spacing,
                            cy: viewport.height - innerOffset,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto inferior esquerdo
                    generateCornerPoints(
                        cornerRadius,
                        viewport.height - cornerRadius,
                        Math.PI/2,
                        Math.PI,
                        cornerRadius,
                        true
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `bottom-left-inner-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Esquerda
                    [...Array(verticalCircles)].map((_, i) =>
                        React.createElement('circle', {
                            key: `left-inner-${i}`,
                            cx: innerOffset,
                            cy: viewport.height - cornerRadius - i * spacing,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    ),

                    // Canto superior esquerdo
                    generateCornerPoints(
                        cornerRadius,
                        cornerRadius,
                        Math.PI,
                        Math.PI * 3/2,
                        cornerRadius,
                        true
                    ).map((point, i) =>
                        React.createElement('circle', {
                            key: `top-left-inner-${i}`,
                            cx: point.x,
                            cy: point.y,
                            r: circleRadius,
                            fill: 'white',
                            className: 'circle-animated circle-pulse',
                            style: { animationDelay: `${getRandomDelay()}s` },
                            filter: 'url(#glow)'
                        })
                    )
                )
            );
        };

        // Componente CameraBackground
        const CameraBackground = () => {
            const videoRef = React.useRef(null);
            const [hasPermission, setHasPermission] = React.useState(null);
            const [error, setError] = React.useState(null);

            React.useEffect(() => {
                let isMounted = true;

                const setupCamera = async () => {
                    try {
                        console.log("Verificando ambiente...");
                        console.log("Protocolo:", window.location.protocol);
                        console.log("Host:", window.location.host);
                        console.log("Contexto seguro:", window.isSecureContext);

                        if (!window.isSecureContext) {
                            console.warn("Contexto não seguro - a API da câmera pode não funcionar");
                        }

                        if (!navigator.mediaDevices) {
                            console.log("mediaDevices não encontrado, tentando fallback...");
                            navigator.mediaDevices = {};
                        }

                        if (!navigator.mediaDevices.getUserMedia) {
                            const legacyGetUserMedia = navigator.getUserMedia ||
                                navigator.webkitGetUserMedia ||
                                navigator.mozGetUserMedia ||
                                navigator.msGetUserMedia;

                            if (legacyGetUserMedia) {
                                console.log("Usando API legada getUserMedia");
                                navigator.mediaDevices.getUserMedia = function(constraints) {
                                    return new Promise((resolve, reject) => {
                                        legacyGetUserMedia.call(navigator, constraints, resolve, reject);
                                    });
                                };
                            } else {
                                throw new Error("Nenhum método getUserMedia encontrado");
                            }
                        }

                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: { ideal: "user" },
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            }
                        });

                        if (!isMounted) return;

                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            await videoRef.current.play();
                            setHasPermission(true);
                        } else {
                            throw new Error("Elemento de vídeo não disponível");
                        }
                    } catch (err) {
                        if (!isMounted) return;
                        console.error("Erro completo:", err);
                        setError(err.message || "Erro ao acessar a câmera");
                        setHasPermission(false);
                    }
                };

                setupCamera();

                return () => {
                    isMounted = false;
                    if (videoRef.current?.srcObject) {
                        const stream = videoRef.current.srcObject;
                        stream.getTracks().forEach(track => track.stop());
                    }
                };
            }, []);

            if (hasPermission === null) {
                return React.createElement('div', { className: 'fixed inset-0 bg-gradient-to-b from-gray-900 to-black' },
                    React.createElement('div', { className: 'fixed inset-0 flex items-center justify-center text-white text-center p-4' },
                        React.createElement('div', { className: 'animate-pulse' },
                            React.createElement('p', null, 'A aguardar acesso à câmera...'),
                            React.createElement('p', { className: 'text-sm mt-2 opacity-75' }, 'Se aparecer um diálogo de permissão, por favor aceite.')
                        )
                    )
                );
            }

            if (hasPermission === false) {
                return React.createElement('div', { className: 'fixed inset-0 bg-gradient-to-b from-gray-900 to-black' },
                    React.createElement('div', { className: 'fixed inset-0 flex items-center justify-center text-white text-center p-4' },
                        React.createElement('p', null, error || 'Acesso à câmera negado')
                    )
                );
            }

            return React.createElement('div', { className: 'fixed inset-0 -z-10 overflow-hidden' },
                React.createElement('video', {
                    ref: videoRef,
                    autoPlay: true,
                    playsInline: true,
                    muted: true,
                    className: 'absolute inset-0 min-w-full min-h-full w-auto h-auto object-cover'
                })
            );
        };

        // Componente Carousel
        const Carousel = () => {
            const [currentIndex, setCurrentIndex] = React.useState(1);
            const [direction, setDirection] = React.useState(null);
            const [isAnimating, setIsAnimating] = React.useState(false);
            const [selectedMachine, setSelectedMachine] = React.useState(null);
            const [viewMode, setViewMode] = React.useState("carousel");
            const [selectedColor, setSelectedColor] = React.useState("Breeze");

            const getPositionedMachines = () => {
                const totalMachines = machines.length;
                return machines.map((machine, index) => {
                    let position;
                    if (index === currentIndex) {
                        position = "center";
                    } else if (index === (currentIndex - 1 + totalMachines) % totalMachines) {
                        position = "left";
                    } else if (index === (currentIndex + 1) % totalMachines) {
                        position = "right";
                    } else if (index < currentIndex) {
                        position = "left";
                    } else {
                        position = "right";
                    }
                    return { ...machine, position };
                });
            };

            const handleClick = (clickDirection) => {
                if (isAnimating) return;
                
                setIsAnimating(true);
                setDirection(clickDirection);
                
                const totalMachines = machines.length;
                if (clickDirection === "left") {
                    setCurrentIndex((prev) => (prev - 1 + totalMachines) % totalMachines);
                } else {
                    setCurrentIndex((prev) => (prev + 1) % totalMachines);
                }
                
                setTimeout(() => {
                    setIsAnimating(false);
                }, 500);
            };

            const handleDiscover = () => {
                const centerMachine = getPositionedMachines().find(m => m.position === "center");
                if (centerMachine) {
                    setSelectedMachine(centerMachine);
                    setSelectedColor("Breeze");
                    setViewMode("detail");
                }
            };

            const handleBack = () => {
                setSelectedMachine(null);
                setViewMode("carousel");
            };

            const handleColorChange = (variant) => {
                setSelectedColor(variant);
            };

            const getImagePath = (machine, colorVariant) => {
                let colorForPath = colorVariant.toUpperCase();
                if (colorVariant === "Terracotta") {
                    colorForPath = "TERRACOTA";
                } else if (colorVariant === "Violet") {
                    colorForPath = "-VIOLET";
                }
                return `public/IMG/${machine.baseModel}/${machine.baseModel}_${colorForPath}.png`;
            };

            const renderCarouselView = () => {
                const positionedMachines = getPositionedMachines();
                
                return React.createElement('div', { className: 'relative w-full h-full' },
                    React.createElement('div', { className: 'relative w-full h-full flex items-center justify-center' },
                        React.createElement('div', { className: 'relative w-[85%] h-[85%] flex items-center justify-center' },
                            // Botões de navegação
                            React.createElement('button', {
                                className: 'absolute left-0 top-0 w-1/3 h-full z-20 bg-transparent cursor-pointer',
                                onClick: () => !isAnimating && handleClick("left"),
                                disabled: isAnimating,
                                'aria-label': 'Imagem anterior'
                            }),
                            React.createElement('button', {
                                className: 'absolute right-0 top-0 w-1/3 h-full z-20 bg-transparent cursor-pointer',
                                onClick: () => !isAnimating && handleClick("right"),
                                disabled: isAnimating,
                                'aria-label': 'Próxima imagem'
                            }),
                            // Imagens das máquinas
                            positionedMachines.map(machine => 
                                React.createElement('div', {
                                    key: machine.id,
                                    className: `absolute inset-0 flex items-center justify-center pointer-events-none 
                                              ${machine.position === 'center' ? 'z-10' : ''}`
                                },
                                    React.createElement('div', {
                                        className: `relative ${
                                            machine.position === 'center' 
                                                ? 'w-[50%] sm:w-[40%] md:w-[35%]' 
                                                : 'w-[30%] sm:w-[25%] md:w-[20%]'
                                        } aspect-square`
                                    },
                                        React.createElement('img', {
                                            src: machine.image,
                                            alt: machine.name,
                                            className: 'object-contain w-full h-full',
                                            draggable: false
                                        })
                                    )
                                )
                            )
                        )
                    ),
                    // Botão Descobrir
                    React.createElement('button', {
                        className: 'absolute bottom-[10%] left-1/2 transform -translate-x-1/2 px-8 py-3 bg-white text-black rounded-full hover:bg-opacity-90 transition-colors',
                        onClick: handleDiscover
                    }, 'Descobrir')
                );
            };

            const renderDetailView = () => {
                if (!selectedMachine) return null;

                return React.createElement('div', { className: 'relative w-full h-full flex flex-col items-center justify-center' },
                    // Botão Voltar
                    React.createElement('button', {
                        className: 'absolute top-8 left-8 text-white hover:text-gray-300 transition-colors',
                        onClick: handleBack
                    }, '← Voltar'),
                    // Imagem da máquina
                    React.createElement('div', { className: 'relative w-[50%] aspect-square' },
                        React.createElement('img', {
                            src: getImagePath(selectedMachine, selectedColor),
                            alt: selectedMachine.name,
                            className: 'object-contain w-full h-full'
                        })
                    ),
                    // Seleção de cores
                    React.createElement('div', { className: 'flex justify-center mt-8' },
                        colorConfig.map(({ color, variant, availableFor }) => {
                            if (availableFor && !availableFor.includes(selectedMachine.baseModel)) {
                                return null;
                            }
                            return React.createElement('div', {
                                key: variant,
                                className: `color-ball ${selectedColor === variant ? 'selected' : ''}`,
                                style: { backgroundColor: color },
                                onClick: () => handleColorChange(variant)
                            });
                        })
                    )
                );
            };

            return React.createElement('div', { className: 'relative w-full h-screen overflow-hidden' },
                React.createElement('div', { className: 'absolute inset-0 flex items-center justify-center' },
                    React.createElement('div', { className: 'relative w-full max-w-[1400px] h-full md:h-[80vh] px-4' },
                        viewMode === "carousel" ? renderCarouselView() : renderDetailView()
                    )
                )
            );
        };

        // Renderizar a aplicação
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html> 